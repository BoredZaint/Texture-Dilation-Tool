<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture Dilation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
            margin-bottom: 20px;
        }
        
        .drop-zone:hover {
            border-color: #764ba2;
            background: #f0f1ff;
        }
        
        .drop-zone.dragover {
            border-color: #764ba2;
            background: #e8e9ff;
            transform: scale(1.02);
        }
        
        .drop-zone-text {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .drop-zone-hint {
            color: #999;
            font-size: 14px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .slider-with-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-with-input input[type="range"] {
            flex: 1;
        }
        
        .slider-with-input input[type="number"] {
            width: 60px;
            padding: 5px 8px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
        }
        
        .slider-with-input input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        label {
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #ccc;
            cursor: not-allowed;
        }
        
        input[type="range"]:disabled::-moz-range-thumb {
            background: #ccc;
            cursor: not-allowed;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            width: 100%;
            margin-bottom: 20px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        
        .canvas-wrapper {
            text-align: center;
            position: relative;
        }
        
        .canvas-wrapper h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .clear-btn {
            background: none;
            border: none;
            color: #d65555;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            padding: 0;
            margin: 0;
            width: auto;
            height: auto;
            display: none;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
            line-height: 1;
            vertical-align: middle;
            flex-shrink: 0;
        }
        
        .clear-btn.visible {
            display: inline-flex;
        }
        
        .clear-btn:hover {
            color: #b84444;
        }
        
        canvas {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            background: repeating-conic-gradient(#eee 0% 25%, white 0% 50%) 50% / 20px 20px;
            position: relative;
        }
        
        .magnifier {
            position: absolute;
            width: 150px;
            height: 150px;
            border: 3px solid #667eea;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            background: repeating-conic-gradient(#eee 0% 25%, white 0% 50%) 50% / 20px 20px;
        }
        
        .hidden {
            display: none;
        }
        
        .processing {
            text-align: center;
            color: #667eea;
            font-weight: 600;
            padding: 20px;
        }
        
        #fileInput {
            display: none;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Texture Dilation Tool</h1>
        <p class="subtitle">Edge-based smooth dilation for game textures</p>
        
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-text">üìÅ Drop image here or click to browse</div>
            <div class="drop-zone-hint">Supports PNG with transparency</div>
        </div>
        
        <input type="file" id="fileInput" accept="image/png,image/jpeg,image/webp">
        
        <div class="controls">
            <div class="control-group">
                <label for="dilationAmount">Dilation Amount</label>
                <div class="slider-with-input">
                    <input type="range" id="dilationAmount" min="1" max="128" value="16">
                    <input type="number" id="dilationAmountInput" min="1" max="128" value="16">
                </div>
                <label style="margin-top: 10px; display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                    <input type="checkbox" id="infiniteDilation" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                    Infinite dilation (fill entire canvas)
                </label>
            </div>
            
            <div class="control-group">
                <label for="smoothness">Blend Smoothness</label>
                <div class="slider-with-input">
                    <input type="range" id="smoothness" min="1" max="10" value="5">
                    <input type="number" id="smoothnessInput" min="1" max="10" value="5">
                </div>
                <label style="margin-top: 10px; display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                    <input type="checkbox" id="makeFullyOpaque" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;" checked>
                    Make all pixels fully opaque
                </label>
            </div>
        </div>
        
        <button id="processBtn" disabled>Process Image</button>
        <button id="downloadBtn" class="hidden">Download Result</button>
        
        <div class="processing hidden" id="processing">Processing... Please wait</div>
        
        <div class="canvas-container hidden" id="canvasContainer">
            <div class="canvas-wrapper">
                <h3>
                    Original
                    <button class="clear-btn" id="clearOriginal" title="Clear original image">√ó</button>
                </h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>
                    Dilated Result
                    <button class="clear-btn" id="clearResult" title="Clear result image">√ó</button>
                </h3>
                <div style="position: relative;">
                    <canvas id="resultCanvas"></canvas>
                    <canvas class="magnifier" id="magnifier"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const originalCanvas = document.getElementById('originalCanvas');
        const resultCanvas = document.getElementById('resultCanvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const processing = document.getElementById('processing');
        const dilationAmountSlider = document.getElementById('dilationAmount');
        const dilationAmountInput = document.getElementById('dilationAmountInput');
        const smoothnessSlider = document.getElementById('smoothness');
        const smoothnessInput = document.getElementById('smoothnessInput');
        const infiniteDilationCheckbox = document.getElementById('infiniteDilation');
        const makeFullyOpaqueCheckbox = document.getElementById('makeFullyOpaque');
        const clearOriginalBtn = document.getElementById('clearOriginal');
        const clearResultBtn = document.getElementById('clearResult');
        
        let currentImage = null;
        let currentFileName = 'image';
        
        const magnifier = document.getElementById('magnifier');
        const magnifierCtx = magnifier.getContext('2d');
        const magnifierSize = 150;
        const zoomLevel = 1.5;
        
        magnifier.width = magnifierSize;
        magnifier.height = magnifierSize;
        
        // Sync slider and number input for dilation amount
        dilationAmountSlider.addEventListener('input', (e) => {
            dilationAmountInput.value = e.target.value;
        });
        
        dilationAmountInput.addEventListener('input', (e) => {
            let val = parseInt(e.target.value) || 1;
            val = Math.max(1, Math.min(128, val));
            e.target.value = val;
            dilationAmountSlider.value = val;
        });
        
        // Sync slider and number input for smoothness
        smoothnessSlider.addEventListener('input', (e) => {
            smoothnessInput.value = e.target.value;
        });
        
        smoothnessInput.addEventListener('input', (e) => {
            let val = parseInt(e.target.value) || 1;
            val = Math.max(1, Math.min(10, val));
            e.target.value = val;
            smoothnessSlider.value = val;
        });
        
        // Handle infinite dilation checkbox
        infiniteDilationCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                dilationAmountSlider.disabled = true;
                dilationAmountInput.disabled = true;
                dilationAmountSlider.parentElement.style.opacity = '0.5';
            } else {
                dilationAmountSlider.disabled = false;
                dilationAmountInput.disabled = false;
                dilationAmountSlider.parentElement.style.opacity = '1';
            }
        });
        
        // Drop zone interactions
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadImage(file);
            }
        });
        
        function loadImage(file) {
            currentFileName = file.name.replace(/\.[^/.]+$/, '');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    displayOriginal(img);
                    processBtn.disabled = false;
                    downloadBtn.classList.add('hidden');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function displayOriginal(img) {
            originalCanvas.width = img.width;
            originalCanvas.height = img.height;
            const ctx = originalCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            canvasContainer.classList.remove('hidden');
            clearOriginalBtn.classList.add('visible');
        }
        
        processBtn.addEventListener('click', () => {
            if (!currentImage) return;
            
            processBtn.disabled = true;
            processing.classList.remove('hidden');
            downloadBtn.classList.add('hidden');
            
            setTimeout(() => {
                processDilation();
            }, 50);
        });
        
        function processDilation() {
            const isInfinite = infiniteDilationCheckbox.checked;
            const makeOpaque = makeFullyOpaqueCheckbox.checked;
            const smoothness = parseInt(smoothnessInput.value);
            const dilationAmount = parseInt(dilationAmountInput.value);
            
            resultCanvas.width = currentImage.width;
            resultCanvas.height = currentImage.height;
            
            const srcCtx = originalCanvas.getContext('2d');
            const dstCtx = resultCanvas.getContext('2d');
            
            let srcData = srcCtx.getImageData(0, 0, currentImage.width, currentImage.height);
            const width = currentImage.width;
            const height = currentImage.height;
            
            // Preprocessing: if makeOpaque is enabled, convert all semi-transparent pixels to opaque first
            if (makeOpaque) {
                for (let i = 0; i < srcData.data.length; i += 4) {
                    const alpha = srcData.data[i + 3];
                    if (alpha > 10) {
                        srcData.data[i + 3] = 255;
                    }
                }
            }
            
            // Edge-based dilation: repeatedly dilate only the edge pixels
            const targetAmount = isInfinite ? Math.max(width, height) : dilationAmount;
            let currentIteration = 0;
            
            while (currentIteration < targetAmount) {
                const edgeData = findEdgePixels(srcData, width, height);
                if (edgeData.edges.length === 0) break;
                
                srcData = dilateEdges(srcData, width, height, edgeData, smoothness);
                currentIteration++;
                
                if (isInfinite && currentIteration % 10 === 0) {
                    if (!checkForTransparency(srcData)) break;
                }
            }
            
            dstCtx.putImageData(srcData, 0, 0);
            
            processing.classList.add('hidden');
            processBtn.disabled = false;
            downloadBtn.classList.remove('hidden');
            clearResultBtn.classList.add('visible');
        }
        
        function findEdgePixels(imageData, width, height) {
            const edges = [];
            const alphaThreshold = 10;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const alpha = imageData.data[idx + 3];
                    
                    if (alpha <= alphaThreshold) {
                        let isEdge = false;
                        for (let dy = -1; dy <= 1 && !isEdge; dy++) {
                            for (let dx = -1; dx <= 1 && !isEdge; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIdx = (ny * width + nx) * 4;
                                    if (imageData.data[nIdx + 3] > alphaThreshold) {
                                        isEdge = true;
                                    }
                                }
                            }
                        }
                        if (isEdge) {
                            edges.push({x, y, idx});
                        }
                    }
                }
            }
            return {edges};
        }
        
        function dilateEdges(srcData, width, height, edgeData, smoothness) {
            const dstData = new ImageData(width, height);
            const alphaThreshold = 10;
            
            for (let i = 0; i < srcData.data.length; i++) {
                dstData.data[i] = srcData.data[i];
            }
            
            const falloffRate = smoothness <= 5 
                ? 2.0 - (smoothness * 0.3)
                : 0.5 - ((smoothness - 5) * 0.08);
            
            for (const edge of edgeData.edges) {
                const {x, y, idx} = edge;
                
                let totalR = 0, totalG = 0, totalB = 0;
                let totalWeight = 0;
                
                const searchRadius = 8;
                for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > searchRadius || dist < 0.1) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                        
                        const nIdx = (ny * width + nx) * 4;
                        const nAlpha = srcData.data[nIdx + 3];
                        
                        if (nAlpha > alphaThreshold) {
                            const weight = Math.exp(-dist * falloffRate);
                            totalR += srcData.data[nIdx] * weight;
                            totalG += srcData.data[nIdx + 1] * weight;
                            totalB += srcData.data[nIdx + 2] * weight;
                            totalWeight += weight;
                        }
                    }
                }
                
                if (totalWeight > 0) {
                    dstData.data[idx] = Math.round(totalR / totalWeight);
                    dstData.data[idx + 1] = Math.round(totalG / totalWeight);
                    dstData.data[idx + 2] = Math.round(totalB / totalWeight);
                    dstData.data[idx + 3] = 255;
                }
            }
            
            return dstData;
        }
        
        function checkForTransparency(imageData) {
            const alphaThreshold = 10;
            for (let i = 3; i < imageData.data.length; i += 4) {
                if (imageData.data[i] <= alphaThreshold) {
                    return true;
                }
            }
            return false;
        }
        
        downloadBtn.addEventListener('click', () => {
            resultCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentFileName}_dilated.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }, 'image/png');
        });
        
        // Magnifier functionality
        resultCanvas.addEventListener('mouseenter', () => {
            magnifier.style.display = 'block';
        });
        
        resultCanvas.addEventListener('mouseleave', () => {
            magnifier.style.display = 'none';
        });
        
        resultCanvas.addEventListener('mousemove', (e) => {
            const rect = resultCanvas.getBoundingClientRect();
            const scaleX = resultCanvas.width / rect.width;
            const scaleY = resultCanvas.height / rect.height;
            
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            const magnifierX = e.clientX - rect.left + 20;
            const magnifierY = e.clientY - rect.top + 20;
            
            magnifier.style.left = magnifierX + 'px';
            magnifier.style.top = magnifierY + 'px';
            
            magnifierCtx.clearRect(0, 0, magnifierSize, magnifierSize);
            
            const sourceSize = magnifierSize / zoomLevel;
            const sourceX = mouseX - sourceSize / 2;
            const sourceY = mouseY - sourceSize / 2;
            
            magnifierCtx.imageSmoothingEnabled = false;
            magnifierCtx.drawImage(
                resultCanvas,
                sourceX, sourceY, sourceSize, sourceSize,
                0, 0, magnifierSize, magnifierSize
            );
            
            magnifierCtx.strokeStyle = '#667eea';
            magnifierCtx.lineWidth = 2;
            magnifierCtx.beginPath();
            magnifierCtx.moveTo(magnifierSize / 2, 0);
            magnifierCtx.lineTo(magnifierSize / 2, magnifierSize);
            magnifierCtx.moveTo(0, magnifierSize / 2);
            magnifierCtx.lineTo(magnifierSize, magnifierSize / 2);
            magnifierCtx.stroke();
        });
        
        // Clear buttons functionality
        clearOriginalBtn.addEventListener('click', () => {
            const ctx = originalCanvas.getContext('2d');
            ctx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            originalCanvas.width = 0;
            originalCanvas.height = 0;
            currentImage = null;
            processBtn.disabled = true;
            downloadBtn.classList.add('hidden');
            clearOriginalBtn.classList.remove('visible');
            
            if (resultCanvas.width === 0) {
                canvasContainer.classList.add('hidden');
            }
        });
        
        clearResultBtn.addEventListener('click', () => {
            const ctx = resultCanvas.getContext('2d');
            ctx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
            resultCanvas.width = 0;
            resultCanvas.height = 0;
            downloadBtn.classList.add('hidden');
            clearResultBtn.classList.remove('visible');
            
            if (originalCanvas.width === 0) {
                canvasContainer.classList.add('hidden');
            }
        });
    </script>
</body>
</html>
